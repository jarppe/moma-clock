(ns clock.numbers)

(def ^:const PI Math/PI)
(def ^:const PIx2 (* PI 2.0))
(def ^:const PIp2 (/ PI 2.0))


(defn ->a [p]
  (-> p
      (* (/ PIx2 8))
      (- PIp2)))

(def numbers (->> [; 0
                   [2 4] [6 4]
                   [0 4] [0 4]
                   [0 2] [0 6]
                   ; 1
                   [5 5] [4 4]
                   [5 5] [0 4]
                   [5 5] [0 0]
                   ; 2
                   [2 2] [6 4]
                   [2 4] [6 0]
                   [0 2] [6 6]
                   ; 3
                   [2 2] [6 4]
                   [2 2] [6 0]
                   [2 2] [6 0]
                   ; 4
                   [4 4] [4 4]
                   [0 2] [6 0]
                   [5 5] [0 0]
                   ; 5
                   [2 4] [6 6]
                   [0 2] [6 4]
                   [2 2] [0 6]
                   ; 6
                   [2 4] [6 6]
                   [0 4] [6 4]
                   [2 0] [0 6]
                   ; 7
                   [2 2] [6 4]
                   [5 5] [0 4]
                   [5 5] [0 0]
                   ; 8
                   [2 4] [6 4]
                   [2 4] [6 4]
                   [2 0] [6 0]
                   ; 9
                   [2 4] [6 4]
                   [0 2] [0 4]
                   [2 2] [6 0]]
                  (map (fn [[a1 a2]]
                         [(->a a1) (->a a2)]))
                  (into [])))

(defn pointers [now x y]
  (let [n (nth now (Math/floor (/ x 2.0)))
        y' (mod y 3)
        x' (mod x 2)]
    (nth numbers (+ (* 6 n)
                    (* 2 y')
                    x'))))

